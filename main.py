#import the necessary modules
import freenect
import cv2 as cv
import numpy as np
from collections import deque
import imutils
from calibReader import CalibReader
import time
from flightPlotter import FlightPlotter
 

#function to get RGB image from kinect
def get_video():
    array,_ = freenect.sync_get_video()
    array = cv.cvtColor(array,cv.COLOR_RGB2BGR)
    return array
 
#function to get depth image from kinect
def get_depth():
    array,_ = freenect.sync_get_depth(format=freenect.DEPTH_REGISTERED)
#    
    return array

# Function to compute stereo rectification maps
def compute_rect_maps(ir_mat, ir_dist, rgb_mat, rgb_dist, trans_vec, rot_mat):
    imgSize = (640, 480) 
    rotation1, rotation2, pose1, pose2, q, roi1, roi2 = cv.stereoRectify(
                                            cameraMatrix1 = ir_mat,
                                            distCoeffs1 = ir_dist,
                                            cameraMatrix2 = rgb_mat,
                                            distCoeffs2 = rgb_dist,
                                            imageSize = imgSize,
                                            R = rot_mat,
                                            T = trans_vec,
                                            flags = cv.CALIB_ZERO_DISPARITY,
                                            newImageSize = imgSize)
   
    ir_map_x, ir_map_y = cv.initUndistortRectifyMap(ir_mat, 
                                                  ir_dist, 
                                                  rotation1, 
                                                  pose1, 
                                                  imgSize,
                                                  cv.CV_32FC1)
    
    rgb_map_x, rgb_map_y = cv.initUndistortRectifyMap(rgb_mat, 
                                                  rgb_dist, 
                                                  rotation2, 
                                                  pose2, 
                                                  imgSize,
                                                  cv.CV_32FC1)
    
    
    return ir_map_x, ir_map_y, rgb_map_x, rgb_map_y

# Function to get current time in millseconds (for timers)
def get_time_millis():
    return int(round(time.time() * 1000))
    
# Function to remap moth frames using maps generated by compute_rect_maps()
def remap_frame(ir_frame, rgb_frame, ir_map_x, ir_map_y, rgb_map_x, rgb_map_y):
    ir_remapped = cv.remap(src = ir_frame,
                           map1 = ir_map_x,
                           map2 = ir_map_y,
                           interpolation = cv.INTER_LINEAR)
    rgb_remapped = cv.remap(src = rgb_frame,
                           map1 = rgb_map_x,
                           map2 = rgb_map_y,
                           interpolation = cv.INTER_LINEAR)
    return ir_remapped, rgb_remapped
 
if __name__ == "__main__":
    
    flight_plotter = FlightPlotter()
    
    # Set green thresholds in HSV
    greenLower = (29, 86, 6)
    greenUpper = (64, 255, 255)
    # Initialize list of tracked points
    pts = deque(maxlen=64)
    
    # Parse the calib.ini file and load into stereo rectifier
    rel_path = "/home/liam/fyp/calib/kinect_calib_values/calib.ini"
    
    calib_reader = CalibReader(rel_path)
    ir_camera_mat, ir_dist_coeffs = calib_reader.get_IR_calib()   
    rgb_camera_mat, rgb_dist_coeffs = calib_reader.get_RGB_calib()
    translation_vector, rotation_matrix = calib_reader.get_stereo_calib()
    
    irMapX, irMapY, rgbMapX, rgbMapY = compute_rect_maps(ir_camera_mat, 
                                                         ir_dist_coeffs, 
                                                         rgb_camera_mat, 
                                                         rgb_dist_coeffs, 
                                                         translation_vector, 
                                                         rotation_matrix)
    
    
    start_time = get_time_millis()

    
    while True:
        # Get RGB video frame
        frame = get_video()
        # Get Depth Sensor frame
        depth = get_depth()
        
        # Blur frame and convert to HSV color space
        blurred = cv.GaussianBlur(frame, (11, 11), 0)
        hsv = cv.cvtColor(blurred, cv.COLOR_BGR2HSV)
        
        # Create mask for green/yellow color of ball
        mask = cv.inRange(hsv, greenLower, greenUpper)
        mask = cv.erode(mask, None, iterations=2)
        mask = cv.dilate(mask, None, iterations=2)
        
        # Find contours in mask
        contours = cv.findContours(mask.copy(), cv.RETR_EXTERNAL,
                                   cv.CHAIN_APPROX_SIMPLE)
        contours = imutils.grab_contours(contours)
        
        # Center of ball
        ballCenter = None
        
        # At least one contour is found
        if len(contours) > 0:
            # Find largest contour and compute enclosing circle and centroid
            c = max(contours, key=cv.contourArea)
            ((x, y), radius) = cv.minEnclosingCircle(c)
            M = cv.moments(c)
            center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
            
            # Radius meets a minimum size
            if radius > 10:
                # Draw circle around the ball
                cv.circle(frame, (int(x), int(y)), int(radius),
                          (0, 255, 255), 2)
                cv.circle(depth, (int(x), int(y)), int(radius),
                          (0, 255, 255), 2)
                # Draw the center point of the ball
                cv.circle(frame, center, 5, (0, 0, 255), -1)
#                cv.circle(depth, center, 5, (0, 0, 255), -1)
                
                depthValue = depth.item(int(y), int(x))
                point_3d = center + (depthValue, )
                
                
                if int(x) >= 40:
                    pts.append(point_3d)
                    print(point_3d)
                    if int(x) >= 600:
                        break
                    
                
#                t = get_time_millis() - start_time
#                
#                # when ball crosses thresholds
#                if int(x) == 80 | int(x) == 320 | int(x) == 560:
#                    # Save the location and the time to tracked points queue
#                    pts.appendleft((center, depthValue, t))
#                    print("Point " + center + ", " + depthValue + " added to pts")
#                    if len(pts) == 3:
#                        flight_recorded = True
#                        print("Flight recorded")
            
        
        cv.imshow('RGB image',frame)
        #display depth image
        depthImage = depth.astype(np.uint8)
        cv.imshow('Depth image', depthImage)
 
        # quit program when 'esc' key is pressed
        k = cv.waitKey(1) & 0xFF
        if k == ord("q"):
            break
    cv.destroyAllWindows()
    flight_plotter.plotFlight(pts)
        
    
    